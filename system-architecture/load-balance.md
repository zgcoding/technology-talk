## 负载均衡
---

### 1、随机算法

从可用的节点中，随机挑选一个节点来访问

一般通过生成一个随机数来实现

https://github.com/weibocom/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/cluster/loadbalance/RandomLoadBalance.java

适用场景：

实现比较简单，在请求量远超可用服务节点数量的情况下，各个服务节点被访问的概率基本相同，主要应用在各个服务节点的性能差异不大的情况下。

### 2、轮询算法

按照固定的顺序，把可用的服务节点，挨个访问一次。

在实现时，轮询算法通常是把所有可用节点放到一个数组里，然后按照数组编号，挨个访问。比如服
务有 10 个节点，放到数组里就是一个大小为 10 的数组，这样的话就可以从序号为 0 的节点开始访
问，访问后序号自动加 1，下一次就会访问序号为 1 的节点，以此类推。

轮询算法能够保证所有节点被访问到的概率是相同的。

https://github.com/weibocom/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/cluster/loadbalance/RoundRobinLoadBalance.java

适用场景：

跟随机算法类似，各个服务节点被访问的概率也基本相同，也主要应用在各个服务节点性能差异不大的情况下。

### 3、加权轮询算法

轮询算法能够保证所有节点被访问的概率相同，而加权轮询算法是在此基础上，给每个节点赋予一个
权重，从而使每个节点被访问到的概率不同，权重大的节点被访问的概率就高，权重小的节点被访问
的概率就小。

在实现时，加权轮询算法是生成一个节点序列，该序列里有 n 个节点，n 是所有节点的权重之和。
在这个序列中，每个节点出现的次数，就是它的权重值。比如有三个节点：a、b、c，权重分别是
3、2、1，那么生成的序列就是{a、a、b、c、b、a}，这样的话按照这个序列访问，前 6 次请求就
会分别访问节点 a 三次，节点 b 两次，节点 c 一次。从第 7 个请求开始，又重新按照这个序列的顺
序来访问节点。

在应用加权轮询算法的时候，根据我的经验，要尽可能保证生产的序列的均匀，如果生成的不均匀会
造成节点访问失衡，比如刚才的例子，如果生成的序列是{a、a、a、b、b、c}，就会导致前 3 次访
问的节点都是 a。

https://github.com/weibocom/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/cluster/loadbalance/ConfigurableWeightLoadBalance.java


适用场景：

主要被用在服务节点性能差异比较大的情况。比如经常会出现一种情况，因为采购时间
的不同，新的服务节点的性能往往要高于旧的节点，这个时候可以给新的节点设置更高的权重，
让它承担更多的请求，充分发挥新节点的性能优势。


### 4、最少活跃连接算法

顾名思义就是每一次访问都选择连接数最少的节点。因为不同节点处理请求的速
度不同，使得同一个服务消费者同每一个节点的连接数都不相同。连接数大的节点，可以认为是处理
请求慢，而连接数小的节点，可以认为是处理请求快。所以在挑选节点时，可以以连接数为依据，选
择连接数最少的节点访问。

在实现时，需要记录跟每一个节点的连接数，这样在选择节点时，才能比较出连接数最小的节点。

https://github.com/weibocom/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/cluster/loadbalance/ActiveWeightLoadBalance.java

适用场景：

与加权轮询算法预先定义好每个节点的访问权重不同，采用最少活跃连接算
法，客户端同服务端节点的连接数是在时刻变化的，理论上连接数越少代表此时服务端节点越空
闲，选择最空闲的节点发起请求，能获取更快的响应速度。尤其在服务端节点性能差异较大，而
又不好做到预先定义权重时，采用最少活跃连接算法是比较好的选择。

### 5、一致性hash 算法

一致性 hash 算法，是通过某个 hash 函数，把同一个来源的请求都映射到同一个节点上。一致性
hash 算法最大的特点就是同一个来源的请求，只会映射到同一个节点上，可以说是具有记忆功能。
只有当这个节点不可用时，请求才会被分配到相邻的可用节点上。

https://github.com/weibocom/motan/blob/master/motan-core/src/main/java/com/weibo/api/motan/cluster/loadbalance/ConsistentHashLoadBalance.java

适用场景：

因为它能够保证同一个客户端的请求始终访问同一个服务节点，所以适合服务端节点处理不同客户端请求差异较大的场景。比如服务端缓存里保存着客户端的请求结果，如果同一客户端一直访问一个服务节点，那么就可以一直从缓存中获取数据。

### 6、自适应最优选择算法

这种算法的主要思路是在客户端本地维护一份同每一个服务节点的性能统计快照，并且每隔一段时间
去更新这个快照。在发起请求时，根据“二八原则”，把服务节点分成两部分，找出 20% 的那部分
响应最慢的节点，然后降低权重。这样的话，客户端就能够实时的根据自身访问每个节点性能的快
慢，动态调整访问最慢的那些节点的权重，来减少访问量，从而可以优化长尾请求。

由此可见，自适应最优选择算法是对加权轮询算法的改良，可以看作是一种**动态加权轮询算法**。它的
实现关键之处就在于两点：第一点是每隔一段时间获取客户端同每个服务节点之间调用的平均性能统
计；第二点是按照这个性能统计对服务节点进行排序，对排在性能倒数 20% 的那部分节点赋予一个
较低的权重，其余的节点赋予正常的权重。

在具体实现时，针对第一点，需要在内存中开辟一块空间记录客户端同每一个服务节点之间调用的平
均性能，并每隔一段固定时间去更新。这个更新的时间间隔不能太短，太短的话很容易受瞬时的性能
抖动影响，导致统计变化太快，没有参考性；同时也不能太长，太长的话时效性就会大打折扣，效果
不佳。根据我的经验，1 分钟的更新时间间隔是个比较合适的值。

针对第二点，关键点是权重值的设定，即使服务节点之间的性能差异较大，也不适合把权重设置得差
异太大，这样会导致性能较好的节点与性能较差的节点之间调用量相差太大，这样也不是一种合理的
状态。在实际设定时，可以设置 20% 性能较差的节点权重为 3，其余节点权重为 5。
